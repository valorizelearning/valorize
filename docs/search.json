[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "VALORIZE",
    "section": "",
    "text": "Meliana Christianti Johan | NIM 33224001\nPromotor: Prof. Ir. Armein Z. R. Langi, M.Sc., Ph.D.\nCo-Promotor: Ir. I Gusti Bagus Baskara Nugraha, S.T., M.T., Ph.D.\nJudul Disertasi:\nKerangka Kerja Manajemen Pengetahuan Kolaboratif Berbasis Rekayasa Cerdas untuk Pendidikan Tinggi Berorientasi Nilai\nCollaborative Knowledge Management Framework Based on Smart Engineering for Value-Oriented Higher Education\n\nIntroduction\nValorize Learning Framework Klik Disini\n\n\n\n\n\n\nKata “Valorize” berasal dari bahasa Prancis valoriser dan akar Latin valor (nilai). Dalam konteks pendidikan, Valorize berarti mengakui, mengembangkan, dan merealisasikan potensi yang ada menjadi nilai nyata yang dapat diukur.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "valorize_introduction.html",
    "href": "valorize_introduction.html",
    "title": "1  Introduction to Valorize",
    "section": "",
    "text": "1.1 VALORIZE LEARNING: Where Value is Realized!\nValorize\nKerangka pembelajaran transformatif yang mengintegrasikan Value (nilai), Collaboration (kolaborasi), Artificial Intelligence (Kecerdasan Buatan), dan Personalized Learning (Pembelajaran yang dipersonalisasi) untuk menciptakan pembelajaran yang bermakna (Value Co-Creation) dalam konteks pendidikan berorientasi nilai (Value Oriented Education).",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Valorize</span>"
    ]
  },
  {
    "objectID": "valorize_introduction.html#visi-misi",
    "href": "valorize_introduction.html#visi-misi",
    "title": "1  Introduction to Valorize",
    "section": "1.2 Visi Misi",
    "text": "1.2 Visi Misi\n\n1.2.1 Visi\nMenjadi kerangka kerja pembelajaran transformatif yang mengakui, mengembangkan, dan merealisasikan potensi peserta didik menjadi kompetensi profesional yang autentik.\n\n\n1.2.2 Misi\nMemfasilitasi transformasi peserta didik dari konsumen pengetahuan pasif menjadi produsen nilai aktif melalui: Kolaborasi bermakna dalam Knowledge Marketplace berbasis peer production Pembelajaran berbasis proyek autentik yang relevan dengan kebutuhan profesional Pengembangan identitas profesional yang kuat dan adaptif.\nKomponen inti framework: 1. VALue (Nilai-nilai luhur sebagai fondasi) 2. Organized through CollaRation (Pembelajaran kolaboratif terorganisir) 3. Intelligence (Kecerdasan Buatan sebagai enabler) 4. Zones of PersonalIzed & Zenith Education (Zona pembelajaran personal menuju puncak potensi)",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Valorize</span>"
    ]
  },
  {
    "objectID": "valorize_content1.html",
    "href": "valorize_content1.html",
    "title": "2  Content1",
    "section": "",
    "text": "2.1 Weather Data\nWhen visualizing a number of different data fields, we might be tempted to use as many visual encoding channels as we can: x, y, color, size, shape, and so on. However, as the number of encoding channels increases, a chart can rapidly become cluttered and difficult to read. An alternative to “over-loading” a single chart is to instead compose multiple charts in a way that facilitates rapid comparisons.\nIn this notebook, we will examine a variety of operations for multi-view composition:\nWe’ll then look at how these operations form a view composition algebra, in which the operations can be combined to build a variety of complex multi-view displays.\nThis notebook is part of the data visualization curriculum.\nWe will be visualizing weather statistics for the U.S. cities of Seattle and New York. Let’s load the dataset and peek at the first and last 10 rows:\nweather = 'https://cdn.jsdelivr.net/npm/vega-datasets@1/data/weather.csv'\ndf = pd.read_csv(weather)\ndf.head(10)\n\n\n\n\n\n\n\n\nlocation\ndate\nprecipitation\ntemp_max\ntemp_min\nwind\nweather\n\n\n\n\n0\nSeattle\n2012-01-01\n0.0\n12.8\n5.0\n4.7\ndrizzle\n\n\n1\nSeattle\n2012-01-02\n10.9\n10.6\n2.8\n4.5\nrain\n\n\n2\nSeattle\n2012-01-03\n0.8\n11.7\n7.2\n2.3\nrain\n\n\n3\nSeattle\n2012-01-04\n20.3\n12.2\n5.6\n4.7\nrain\n\n\n4\nSeattle\n2012-01-05\n1.3\n8.9\n2.8\n6.1\nrain\n\n\n5\nSeattle\n2012-01-06\n2.5\n4.4\n2.2\n2.2\nrain\n\n\n6\nSeattle\n2012-01-07\n0.0\n7.2\n2.8\n2.3\nrain\n\n\n7\nSeattle\n2012-01-08\n0.0\n10.0\n2.8\n2.0\nsun\n\n\n8\nSeattle\n2012-01-09\n4.3\n9.4\n5.0\n3.4\nrain\n\n\n9\nSeattle\n2012-01-10\n1.0\n6.1\n0.6\n3.4\nrain\ndf.tail(10)\n\n\n\n\n\n\n\n\nlocation\ndate\nprecipitation\ntemp_max\ntemp_min\nwind\nweather\n\n\n\n\n2912\nNew York\n2015-12-22\n4.8\n15.6\n11.1\n3.8\nfog\n\n\n2913\nNew York\n2015-12-23\n29.5\n17.2\n8.9\n4.5\nfog\n\n\n2914\nNew York\n2015-12-24\n0.5\n20.6\n13.9\n4.9\nfog\n\n\n2915\nNew York\n2015-12-25\n2.5\n17.8\n11.1\n0.9\nfog\n\n\n2916\nNew York\n2015-12-26\n0.3\n15.6\n9.4\n4.8\ndrizzle\n\n\n2917\nNew York\n2015-12-27\n2.0\n17.2\n8.9\n5.5\nfog\n\n\n2918\nNew York\n2015-12-28\n1.3\n8.9\n1.7\n6.3\nsnow\n\n\n2919\nNew York\n2015-12-29\n16.8\n9.4\n1.1\n5.3\nfog\n\n\n2920\nNew York\n2015-12-30\n9.4\n10.6\n5.0\n3.0\nfog\n\n\n2921\nNew York\n2015-12-31\n1.5\n11.1\n6.1\n5.5\nfog\nWe will create multi-view displays to examine weather within and across the cities.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Content1</span>"
    ]
  },
  {
    "objectID": "valorize_content1.html#layer",
    "href": "valorize_content1.html#layer",
    "title": "2  Content1",
    "section": "2.2 Layer",
    "text": "2.2 Layer\nOne of the most common ways of combining multiple charts is to layer marks on top of each other. If the underlying scale domains are compatible, we can merge them to form shared axes. If either of the x or y encodings is not compatible, we might instead create a dual-axis chart, which overlays marks using separate scales and axes.\n\n2.2.1 Shared Axes\nLet’s start by plotting the minimum and maximum average temperatures per month:\n\nalt.Chart(weather).mark_area().encode(\n  alt.X('month(date):T'),\n  alt.Y('average(temp_max):Q'),\n  alt.Y2('average(temp_min):Q')\n)\n\n\n\n\n\n\nThe plot shows us temperature ranges for each month over the entirety of our data. However, this is pretty misleading as it aggregates the measurements for both Seattle and New York!\nLet’s subdivide the data by location using a color encoding, while also adjusting the mark opacity to accommodate overlapping areas:\n\nalt.Chart(weather).mark_area(opacity=0.3).encode(\n  alt.X('month(date):T'),\n  alt.Y('average(temp_max):Q'),\n  alt.Y2('average(temp_min):Q'),\n  alt.Color('location:N')\n)\n\n\n\n\n\n\nWe can see that Seattle is more temperate: warmer in the winter, and cooler in the summer.\nIn this case we’ve created a layered chart without any special features by simply subdividing the area marks by color. While the chart above shows us the temperature ranges, we might also want to emphasize the middle of the range.\nLet’s create a line chart showing the average temperature midpoint. We’ll use a calculate transform to compute the midpoints between the minimum and maximum daily temperatures:\n\nalt.Chart(weather).mark_line().transform_calculate(\n  temp_mid='(+datum.temp_min + +datum.temp_max) / 2'\n).encode(\n  alt.X('month(date):T'),\n  alt.Y('average(temp_mid):Q'),\n  alt.Color('location:N')\n)\n\n\n\n\n\n\nAside: note the use of +datum.temp_min within the calculate transform. As we are loading the data directly from a CSV file without any special parsing instructions, the temperature values may be internally represented as string values. Adding the + in front of the value forces it to be treated as a number.\nWe’d now like to combine these charts by layering the midpoint lines over the range areas. Using the syntax chart1 + chart2, we can specify that we want a new layered chart in which chart1 is the first layer and chart2 is a second layer drawn on top:\n\ntempMinMax = alt.Chart(weather).mark_area(opacity=0.3).encode(\n  alt.X('month(date):T'),\n  alt.Y('average(temp_max):Q'),\n  alt.Y2('average(temp_min):Q'),\n  alt.Color('location:N')\n)\n\ntempMid = alt.Chart(weather).mark_line().transform_calculate(\n  temp_mid='(+datum.temp_min + +datum.temp_max) / 2'\n).encode(\n  alt.X('month(date):T'),\n  alt.Y('average(temp_mid):Q'),\n  alt.Color('location:N')\n)\n\ntempMinMax + tempMid\n\n\n\n\n\n\nNow we have a multi-layer plot! However, the y-axis title (though informative) has become a bit long and unruly…\nLet’s customize our axes to clean up the plot. If we set a custom axis title within one of the layers, it will automatically be used as a shared axis title for all the layers:\n\ntempMinMax = alt.Chart(weather).mark_area(opacity=0.3).encode(\n  alt.X('month(date):T', title=None, axis=alt.Axis(format='%b')),\n  alt.Y('average(temp_max):Q', title='Avg. Temperature °C'),\n  alt.Y2('average(temp_min):Q'),\n  alt.Color('location:N')\n)\n\ntempMid = alt.Chart(weather).mark_line().transform_calculate(\n  temp_mid='(+datum.temp_min + +datum.temp_max) / 2'\n).encode(\n  alt.X('month(date):T'),\n  alt.Y('average(temp_mid):Q'),\n  alt.Color('location:N')\n)\n\ntempMinMax + tempMid\n\n\n\n\n\n\nWhat happens if both layers have custom axis titles? Modify the code above to find out…\nAbove used the + operator, a convenient shorthand for Altair’s layer method. We can generate an identical layered chart using the layer method directly:\n\nalt.layer(tempMinMax, tempMid)\n\n\n\n\n\n\nNote that the order of inputs to a layer matters, as subsequent layers will be drawn on top of earlier layers. Try swapping the order of the charts in the cells above. What happens? (Hint: look closely at the color of the line marks.)\n\n\n2.2.2 Dual-Axis Charts\nSeattle has a reputation as a rainy city. Is that deserved?\nLet’s look at precipitation alongside temperature to learn more. First let’s create a base plot the shows average monthly precipitation in Seattle:\n\nalt.Chart(weather).transform_filter(\n  'datum.location == \"Seattle\"'\n).mark_line(\n  interpolate='monotone',\n  stroke='grey'\n).encode(\n  alt.X('month(date):T', title=None),\n  alt.Y('average(precipitation):Q', title='Precipitation')\n)\n\n\n\n\n\n\nTo facilitate comparison with the temperature data, let’s create a new layered chart. Here’s what happens if we try to layer the charts as we did earlier:\n\ntempMinMax = alt.Chart(weather).transform_filter(\n  'datum.location == \"Seattle\"'\n).mark_area(opacity=0.3).encode(\n  alt.X('month(date):T', title=None, axis=alt.Axis(format='%b')),\n  alt.Y('average(temp_max):Q', title='Avg. Temperature °C'),\n  alt.Y2('average(temp_min):Q')\n)\n\nprecip = alt.Chart(weather).transform_filter(\n  'datum.location == \"Seattle\"'\n).mark_line(\n  interpolate='monotone',\n  stroke='grey'\n).encode(\n  alt.X('month(date):T'),\n  alt.Y('average(precipitation):Q', title='Precipitation')\n)\n\nalt.layer(tempMinMax, precip)\n\n\n\n\n\n\nThe precipitation values use a much smaller range of the y-axis then the temperatures!\nBy default, layered charts use a shared domain: the values for the x-axis or y-axis are combined across all the layers to determine a shared extent. This default behavior assumes that the layered values have the same units. However, this doesn’t hold up for this example, as we are combining temperature values (degrees Celsius) with precipitation values (inches)!\nIf we want to use different y-axis scales, we need to specify how we want Altair to resolve the data across layers. In this case, we want to resolve the y-axis scale domains to be independent rather than use a shared domain. The Chart object produced by a layer operator includes a resolve_scale method with which we can specify the desired resolution:\n\ntempMinMax = alt.Chart(weather).transform_filter(\n  'datum.location == \"Seattle\"'\n).mark_area(opacity=0.3).encode(\n  alt.X('month(date):T', title=None, axis=alt.Axis(format='%b')),\n  alt.Y('average(temp_max):Q', title='Avg. Temperature °C'),\n  alt.Y2('average(temp_min):Q')\n)\n\nprecip = alt.Chart(weather).transform_filter(\n  'datum.location == \"Seattle\"'\n).mark_line(\n  interpolate='monotone',\n  stroke='grey'\n).encode(\n  alt.X('month(date):T'),\n  alt.Y('average(precipitation):Q', title='Precipitation')\n)\n\nalt.layer(tempMinMax, precip).resolve_scale(y='independent')\n\n\n\n\n\n\nWe can now see that autumn is the rainiest season in Seattle (peaking in November), complemented by dry summers.\nYou may have noticed some redundancy in our plot specifications above: both use the same dataset and the same filter to look at Seattle only. If you want, you can streamline the code a bit by providing the data and filter transform to the top-level layered chart. The individual layers will then inherit the data if they don’t have their own data definitions:\n\ntempMinMax = alt.Chart().mark_area(opacity=0.3).encode(\n  alt.X('month(date):T', title=None, axis=alt.Axis(format='%b')),\n  alt.Y('average(temp_max):Q', title='Avg. Temperature °C'),\n  alt.Y2('average(temp_min):Q')\n)\n\nprecip = alt.Chart().mark_line(\n  interpolate='monotone',\n  stroke='grey'\n).encode(\n  alt.X('month(date):T'),\n  alt.Y('average(precipitation):Q', title='Precipitation')\n)\n\nalt.layer(tempMinMax, precip, data=weather).transform_filter(\n  'datum.location == \"Seattle\"'\n).resolve_scale(y='independent')\n\n\n\n\n\n\nWhile dual-axis charts can be useful, they are often prone to misinterpretation, as the different units and axis scales may be incommensurate. As is feasible, you might consider transformations that map different data fields to shared units, for example showing quantiles or relative percentage change.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Content1</span>"
    ]
  },
  {
    "objectID": "valorize_content1.html#facet",
    "href": "valorize_content1.html#facet",
    "title": "2  Content1",
    "section": "2.3 Facet",
    "text": "2.3 Facet\nFaceting involves subdividing a dataset into groups and creating a separate plot for each group. In earlier notebooks, we learned how to create faceted charts using the row and column encoding channels. We’ll first review those channels and then show how they are instances of the more general facet operator.\nLet’s start with a basic histogram of maximum temperature values in Seattle:\n\nalt.Chart(weather).mark_bar().transform_filter(\n  'datum.location == \"Seattle\"'\n).encode(\n  alt.X('temp_max:Q', bin=True, title='Temperature (°C)'),\n  alt.Y('count():Q')\n)\n\n\n\n\n\n\nHow does this temperature profile change based on the weather of a given day – that is, whether there was drizzle, fog, rain, snow, or sun?\nLet’s use the column encoding channel to facet the data by weather type. We can also use color as a redundant encoding, using a customized color range:\n\ncolors = alt.Scale(\n  domain=['drizzle', 'fog', 'rain', 'snow', 'sun'],\n  range=['#aec7e8', '#c7c7c7', '#1f77b4', '#9467bd', '#e7ba52']\n)\n\nalt.Chart(weather).mark_bar().transform_filter(\n  'datum.location == \"Seattle\"'\n).encode(\n  alt.X('temp_max:Q', bin=True, title='Temperature (°C)'),\n  alt.Y('count():Q'),\n  alt.Color('weather:N', scale=colors),\n  alt.Column('weather:N')\n).properties(\n  width=150,\n  height=150\n)\n\n\n\n\n\n\nUnsurprisingly, those rare snow days center on the coldest temperatures, followed by rainy and foggy days. Sunny days are warmer and, despite Seattle stereotypes, are the most plentiful. Though as any Seattleite can tell you, the drizzle occasionally comes, no matter the temperature!\nIn addition to row and column encoding channels within a chart definition, we can take a basic chart definition and apply faceting using an explicit facet operator.\nLet’s recreate the chart above, but this time using facet. We start with the same basic histogram definition, but remove the data source, filter transform, and column channel. We can then invoke the facet method, passing in the data and specifying that we should facet into columns according to the weather field. The facet method accepts both row and column arguments. The two can be used together to create a 2D grid of faceted plots.\nFinally we include our filter transform, applying it to the top-level faceted chart. While we could apply the filter transform to the histogram definition as before, that is slightly less efficient. Rather than filter out “New York” values within each facet cell, applying the filter to the faceted chart lets Vega-Lite know that we can filter out those values up front, prior to the facet subdivision.\n\ncolors = alt.Scale(\n  domain=['drizzle', 'fog', 'rain', 'snow', 'sun'],\n  range=['#aec7e8', '#c7c7c7', '#1f77b4', '#9467bd', '#e7ba52']\n)\n\nalt.Chart().mark_bar().encode(\n  alt.X('temp_max:Q', bin=True, title='Temperature (°C)'),\n  alt.Y('count():Q'),\n  alt.Color('weather:N', scale=colors)\n).properties(\n  width=150,\n  height=150\n).facet(\n  data=weather,\n  column='weather:N'\n).transform_filter(\n  'datum.location == \"Seattle\"'\n)\n\n\n\n\n\n\nGiven all the extra code above, why would we want to use an explicit facet operator? For basic charts, we should certainly use the column or row encoding channels if we can. However, using the facet operator explicitly is useful if we want to facet composed views, such as layered charts.\nLet’s revisit our layered temperature plots from earlier. Instead of plotting data for New York and Seattle in the same plot, let’s break them up into separate facets. The individual chart definitions are nearly the same as before: one area chart and one line chart. The only difference is that this time we won’t pass the data directly to the chart constructors; we’ll wait and pass it to the facet operator later. We can layer the charts much as before, then invoke facet on the layered chart object, passing in the data and specifying column facets based on the location field:\n\ntempMinMax = alt.Chart().mark_area(opacity=0.3).encode(\n  alt.X('month(date):T', title=None, axis=alt.Axis(format='%b')),\n  alt.Y('average(temp_max):Q', title='Avg. Temperature (°C)'),\n  alt.Y2('average(temp_min):Q'),\n  alt.Color('location:N')\n)\n\ntempMid = alt.Chart().mark_line().transform_calculate(\n  temp_mid='(+datum.temp_min + +datum.temp_max) / 2'\n).encode(\n  alt.X('month(date):T'),\n  alt.Y('average(temp_mid):Q'),\n  alt.Color('location:N')\n)\n\nalt.layer(tempMinMax, tempMid).facet(\n  data=weather,\n  column='location:N'\n)\n\n\n\n\n\n\nThe faceted charts we have seen so far use the same axis scale domains across the facet cells. This default of using shared scales and axes helps aid accurate comparison of values. However, in some cases you may wish to scale each chart independently, for example if the range of values in the cells differs significantly.\nSimilar to layered charts, faceted charts also support resolving to independent scales or axes across plots. Let’s see what happens if we call the resolve_axis method to request independent y-axes:\n\ntempMinMax = alt.Chart().mark_area(opacity=0.3).encode(\n  alt.X('month(date):T', title=None, axis=alt.Axis(format='%b')),\n  alt.Y('average(temp_max):Q', title='Avg. Temperature (°C)'),\n  alt.Y2('average(temp_min):Q'),\n  alt.Color('location:N')\n)\n\ntempMid = alt.Chart().mark_line().transform_calculate(\n  temp_mid='(+datum.temp_min + +datum.temp_max) / 2'\n).encode(\n  alt.X('month(date):T'),\n  alt.Y('average(temp_mid):Q'),\n  alt.Color('location:N')\n)\n\nalt.layer(tempMinMax, tempMid).facet(\n  data=weather,\n  column='location:N'\n).resolve_axis(y='independent')\n\n\n\n\n\n\nThe chart above looks largely unchanged, but the plot for Seattle now includes its own axis.\nWhat if we instead call resolve_scale to resolve the underlying scale domains?\n\ntempMinMax = alt.Chart().mark_area(opacity=0.3).encode(\n  alt.X('month(date):T', title=None, axis=alt.Axis(format='%b')),\n  alt.Y('average(temp_max):Q', title='Avg. Temperature (°C)'),\n  alt.Y2('average(temp_min):Q'),\n  alt.Color('location:N')\n)\n\ntempMid = alt.Chart().mark_line().transform_calculate(\n  temp_mid='(+datum.temp_min + +datum.temp_max) / 2'\n).encode(\n  alt.X('month(date):T'),\n  alt.Y('average(temp_mid):Q'),\n  alt.Color('location:N')\n)\n\nalt.layer(tempMinMax, tempMid).facet(\n  data=weather,\n  column='location:N'\n).resolve_scale(y='independent')\n\n\n\n\n\n\nNow we see facet cells with different axis scale domains. In this case, using independent scales seems like a bad idea! The domains aren’t very different, and one might be fooled into thinking that New York and Seattle have similar maximum summer temperatures.\nTo borrow a cliché: just because you can do something, doesn’t mean you should…",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Content1</span>"
    ]
  },
  {
    "objectID": "valorize_content1.html#concatenate",
    "href": "valorize_content1.html#concatenate",
    "title": "2  Content1",
    "section": "2.4 Concatenate",
    "text": "2.4 Concatenate\nFaceting creates small multiple plots that show separate subdivisions of the data. However, we might wish to create a multi-view display with different views of the same dataset (not subsets) or views involving different datasets.\nAltair provides concatenation operators to combine arbitrary charts into a composed chart. The hconcat operator (shorthand | ) performs horizontal concatenation, while the vconcat operator (shorthand &) performs vertical concatenation.\nLet’s start with a basic line chart showing the average maximum temperature per month for both New York and Seattle, much like we’ve seen before:\n\nalt.Chart(weather).mark_line().encode(\n  alt.X('month(date):T', title=None),\n  alt.Y('average(temp_max):Q'),\n  color='location:N'\n)\n\n\n\n\n\n\nWhat if we want to compare not just temperature over time, but also precipitation and wind levels?\nLet’s create a concatenated chart consisting of three plots. We’ll start by defining a “base” chart definition that contains all the aspects that should be shared by our three plots. We can then modify this base chart to create customized variants, with different y-axis encodings for the temp_max, precipitation, and wind fields. We can then concatenate them using the pipe (|) shorthand operator:\n\nbase = alt.Chart(weather).mark_line().encode(\n  alt.X('month(date):T', title=None),\n  color='location:N'\n).properties(\n  width=240,\n  height=180\n)\n\ntemp = base.encode(alt.Y('average(temp_max):Q'))\nprecip = base.encode(alt.Y('average(precipitation):Q'))\nwind = base.encode(alt.Y('average(wind):Q'))\n\ntemp | precip | wind\n\n\n\n\n\n\nAlternatively, we could use the more explicit alt.hconcat() method in lieu of the pipe | operator. Try rewriting the code above to use hconcat instead.\nVertical concatenation works similarly to horizontal concatenation. Using the & operator (or alt.vconcat method), modify the code to use a vertical ordering instead of a horizontal ordering.\nFinally, note that horizontal and vertical concatenation can be combined. What happens if you write something like (temp | precip) & wind?\nAside: Note the importance of those parentheses… what happens if you remove them? Keep in mind that these overloaded operators are still subject to Python’s operator precendence rules, and so vertical concatenation with & will take precedence over horizontal concatenation with |!\nAs we will revisit later, concatenation operators let you combine any and all charts into a multi-view dashboard!",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Content1</span>"
    ]
  },
  {
    "objectID": "valorize_content1.html#repeat",
    "href": "valorize_content1.html#repeat",
    "title": "2  Content1",
    "section": "2.5 Repeat",
    "text": "2.5 Repeat\nThe concatenation operators above are quite general, allowing arbitrary charts to be composed. Nevertheless, the example above was still a bit verbose: we have three very similar charts, yet have to define them separately and then concatenate them.\nFor cases where only one or two variables are changing, the repeat operator provides a convenient shortcut for creating multiple charts. Given a template specification with some free variables, the repeat operator will then create a chart for each specified assignment to those variables.\nLet’s recreate our concatenation example above using the repeat operator. The only aspect that changes across charts is the choice of data field for the y encoding channel. To create a template specification, we can use the repeater variable alt.repeat('column') as our y-axis field. This code simply states that we want to use the variable assigned to the column repeater, which organizes repeated charts in a horizontal direction. (As the repeater provides the field name only, we have to specify the field data type separately as type='quantitative'.)\nWe then invoke the repeat method, passing in data field names for each column:\n\nalt.Chart(weather).mark_line().encode(\n  alt.X('month(date):T',title=None),\n  alt.Y(alt.repeat('column'), aggregate='average', type='quantitative'),\n  color='location:N'\n).properties(\n  width=240,\n  height=180\n).repeat(\n  column=['temp_max', 'precipitation', 'wind']\n)\n\n\n\n\n\n\nRepetition is supported for both columns and rows. What happens if you modify the code above to use row instead of column?\nWe can also use row and column repetition together! One common visualization for exploratory data analysis is the scatter plot matrix (or SPLOM). Given a collection of variables to inspect, a SPLOM provides a grid of all pairwise plots of those variables, allowing us to assess potential associations.\nLet’s use the repeat operator to create a SPLOM for the temp_max, precipitation, and wind fields. We first create our template specification, with repeater variables for both the x- and y-axis data fields. We then invoke repeat, passing in arrays of field names to use for both row and column. Altair will then generate the cross product (or, Cartesian product) to create the full space of repeated charts:\n\nalt.Chart().mark_point(filled=True, size=15, opacity=0.5).encode(\n  alt.X(alt.repeat('column'), type='quantitative'),\n  alt.Y(alt.repeat('row'), type='quantitative')\n).properties(\n  width=150,\n  height=150\n).repeat(\n  data=weather,\n  row=['temp_max', 'precipitation', 'wind'],\n  column=['wind', 'precipitation', 'temp_max']\n).transform_filter(\n  'datum.location == \"Seattle\"'\n)\n\n\n\n\n\n\nLooking at these plots, there does not appear to be a strong association between precipitation and wind, though we do see that extreme wind and precipitation events occur in similar temperature ranges (~5-15° C). However, this observation is not particularly surprising: if we revisit our histogram at the beginning of the facet section, we can plainly see that the days with maximum temperatures in the range of 5-15° C are the most commonly occurring.\nModify the code above to get a better understanding of chart repetition. Try adding another variable (temp_min) to the SPLOM. What happens if you rearrange the order of the field names in either the row or column parameters for the repeat operator?\nFinally, to really appreciate what the repeat operator provides, take a moment to imagine how you might recreate the SPLOM above using only hconcat and vconcat!",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Content1</span>"
    ]
  },
  {
    "objectID": "valorize_content1.html#a-view-composition-algebra",
    "href": "valorize_content1.html#a-view-composition-algebra",
    "title": "2  Content1",
    "section": "2.6 A View Composition Algebra",
    "text": "2.6 A View Composition Algebra\nTogether, the composition operators layer, facet, concat, and repeat form a view composition algebra: the various operators can be combined to construct a variety of multi-view visualizations.\nAs an example, let’s start with two basic charts: a histogram and a simple line (a single rule mark) showing a global average.\n\nbasic1 = alt.Chart(weather).transform_filter(\n  'datum.location == \"Seattle\"'\n).mark_bar().encode(\n  alt.X('month(date):O'),\n  alt.Y('average(temp_max):Q')\n)\n\nbasic2 = alt.Chart(weather).transform_filter(\n  'datum.location == \"Seattle\"'\n).mark_rule(stroke='firebrick').encode(\n  alt.Y('average(temp_max):Q')\n)\n\nbasic1 | basic2\n\n\n\n\n\n\nWe can then combine the two charts using a layer operator, and then repeat that layered chart to show histograms with overlaid averages for multiple fields:\n\nalt.layer(\n  alt.Chart().mark_bar().encode(\n    alt.X('month(date):O', title='Month'),\n    alt.Y(alt.repeat('column'), aggregate='average', type='quantitative')\n  ),\n  alt.Chart().mark_rule(stroke='firebrick').encode(\n    alt.Y(alt.repeat('column'), aggregate='average', type='quantitative')\n  )\n).properties(\n  width=200,\n  height=150\n).repeat(\n  data=weather,\n  column=['temp_max', 'precipitation', 'wind']\n).transform_filter(\n  'datum.location == \"Seattle\"'\n)\n\n\n\n\n\n\nFocusing only on the multi-view composition operators, the model for the visualization above is:\nrepeat(column=[...])\n|- layer\n   |- basic1\n   |- basic2\nNow let’s explore how we can apply all the operators within a final dashboard that provides an overview of Seattle weather. We’ll combine the SPLOM and faceted histogram displays from earlier sections with the repeated histograms above:\n\nsplom = alt.Chart().mark_point(filled=True, size=15, opacity=0.5).encode(\n  alt.X(alt.repeat('column'), type='quantitative'),\n  alt.Y(alt.repeat('row'), type='quantitative')\n).properties(\n  width=125,\n  height=125\n).repeat(\n  row=['temp_max', 'precipitation', 'wind'],\n  column=['wind', 'precipitation', 'temp_max']\n)\n\ndateHist = alt.layer(\n  alt.Chart().mark_bar().encode(\n    alt.X('month(date):O', title='Month'),\n    alt.Y(alt.repeat('row'), aggregate='average', type='quantitative')\n  ),\n  alt.Chart().mark_rule(stroke='firebrick').encode(\n    alt.Y(alt.repeat('row'), aggregate='average', type='quantitative')\n  )\n).properties(\n  width=175,\n  height=125\n).repeat(\n  row=['temp_max', 'precipitation', 'wind']\n)\n\ntempHist = alt.Chart(weather).mark_bar().encode(\n  alt.X('temp_max:Q', bin=True, title='Temperature (°C)'),\n  alt.Y('count():Q'),\n  alt.Color('weather:N', scale=alt.Scale(\n    domain=['drizzle', 'fog', 'rain', 'snow', 'sun'],\n    range=['#aec7e8', '#c7c7c7', '#1f77b4', '#9467bd', '#e7ba52']\n  ))\n).properties(\n  width=115,\n  height=100\n).facet(\n  column='weather:N'\n)\n\nalt.vconcat(\n  alt.hconcat(splom, dateHist),\n  tempHist,\n  data=weather,\n  title='Seattle Weather Dashboard'\n).transform_filter(\n  'datum.location == \"Seattle\"'\n).resolve_legend(\n  color='independent'\n).configure_axis(\n  labelAngle=0\n)\n\n\n\n\n\n\nThe full composition model for this dashboard is:\nvconcat\n|- hconcat\n|  |- repeat(row=[...], column=[...])\n|  |  |- splom base chart\n|  |- repeat(row=[...])\n|     |- layer\n|        |- dateHist base chart 1\n|        |- dateHist base chart 2\n|- facet(column='weather')\n   |- tempHist base chart\nPhew! The dashboard also includes a few customizations to improve the layout:\n\nWe adjust chart width and height properties to assist alignment and ensure the full visualization fits on the screen.\nWe add resolve_legend(color='independent') to ensure the color legend is associated directly with the colored histograms by temperature. Otherwise, the legend will resolve to the dashboard as a whole.\nWe use configure_axis(labelAngle=0) to ensure that no axis labels are rotated. This helps to ensure proper alignment among the scatter plots in the SPLOM and the histograms by month on the right.\n\nTry removing or modifying any of these adjustments and see how the dashboard layout responds!\nThis dashboard can be reused to show data for other locations or from other datasets. Update the dashboard to show weather patterns for New York instead of Seattle.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Content1</span>"
    ]
  },
  {
    "objectID": "valorize_content1.html#summary",
    "href": "valorize_content1.html#summary",
    "title": "2  Content1",
    "section": "2.7 Summary",
    "text": "2.7 Summary\nFor more details on multi-view composition, including control over sub-plot spacing and header labels, see the Altair Compound Charts documentation.\nNow that we’ve seen how to compose multiple views, we’re ready to put them into action. In addition to statically presenting data, multiple views can enable interactive multi-dimensional exploration. For example, using linked selections we can highlight points in one view to see corresponding values highlight in other views.\nIn the next notebook, we’ll examine how to author interactive selections for both individual plots and multi-view compositions.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Content1</span>"
    ]
  },
  {
    "objectID": "valorize_content2.html",
    "href": "valorize_content2.html",
    "title": "3  Content 2",
    "section": "",
    "text": "3.1 Antibiotics Data\nVisual encoding – mapping data to visual variables such as position, size, shape, or color – is the beating heart of data visualization. The workhorse that actually performs this mapping is the scale: a function that takes a data value as input (the scale domain) and returns a visual value, such as a pixel position or RGB color, as output (the scale range). Of course, a visualization is useless if no one can figure out what it conveys! In addition to graphical marks, a chart needs reference elements, or guides, that allow readers to decode the graphic. Guides such as axes (which visualize scales with spatial ranges) and legends (which visualize scales with color, size, or shape ranges), are the unsung heroes of effective data visualization!\nIn this notebook, we will explore the options Altair provides to support customized designs of scale mappings, axes, and legends, using a running example about the effectiveness of antibiotic drugs.\nThis notebook is part of the data visualization curriculum.\nAfter World War II, antibiotics were considered “wonder drugs”, as they were an easy remedy for what had been intractable ailments. To learn which drug worked most effectively for which bacterial infection, performance of the three most popular antibiotics on 16 bacteria were gathered.\nWe will be using an antibiotics dataset from the vega-datasets collection. In the examples below, we will pass the URL directly to Altair:\nantibiotics = 'https://cdn.jsdelivr.net/npm/vega-datasets@1/data/burtin.json'\nWe can first load the data with Pandas to view the dataset in its entirety and get acquainted with the available fields:\npd.read_json(antibiotics)\n\n\n\n\n\n\n\n\nBacteria\nPenicillin\nStreptomycin\nNeomycin\nGram_Staining\nGenus\n\n\n\n\n0\nAerobacter aerogenes\n870.000\n1.00\n1.600\nnegative\nother\n\n\n1\nBacillus anthracis\n0.001\n0.01\n0.007\npositive\nother\n\n\n2\nBrucella abortus\n1.000\n2.00\n0.020\nnegative\nother\n\n\n3\nDiplococcus pneumoniae\n0.005\n11.00\n10.000\npositive\nother\n\n\n4\nEscherichia coli\n100.000\n0.40\n0.100\nnegative\nother\n\n\n5\nKlebsiella pneumoniae\n850.000\n1.20\n1.000\nnegative\nother\n\n\n6\nMycobacterium tuberculosis\n800.000\n5.00\n2.000\nnegative\nother\n\n\n7\nProteus vulgaris\n3.000\n0.10\n0.100\nnegative\nother\n\n\n8\nPseudomonas aeruginosa\n850.000\n2.00\n0.400\nnegative\nother\n\n\n9\nSalmonella (Eberthella) typhosa\n1.000\n0.40\n0.008\nnegative\nSalmonella\n\n\n10\nSalmonella schottmuelleri\n10.000\n0.80\n0.090\nnegative\nSalmonella\n\n\n11\nStaphylococcus albus\n0.007\n0.10\n0.001\npositive\nStaphylococcus\n\n\n12\nStaphylococcus aureus\n0.030\n0.03\n0.001\npositive\nStaphylococcus\n\n\n13\nStreptococcus fecalis\n1.000\n1.00\n0.100\npositive\nStreptococcus\n\n\n14\nStreptococcus hemolyticus\n0.001\n14.00\n10.000\npositive\nStreptococcus\n\n\n15\nStreptococcus viridans\n0.005\n10.00\n40.000\npositive\nStreptococcus\nThe numeric values in the table indicate the minimum inhibitory concentration (MIC), a measure of the effectiveness of the antibiotic, which represents the concentration of antibiotic (in micrograms per milliliter) required to prevent growth in vitro. The reaction of the bacteria to a procedure called Gram staining is described by the nominal field Gram_Staining. Bacteria that turn dark blue or violet are Gram-positive. Otherwise, they are Gram-negative.\nAs we examine different visualizations of this dataset, ask yourself: What might we learn about the relative effectiveness of the antibiotics? What might we learn about the bacterial species based on their antibiotic response?",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Content 2</span>"
    ]
  },
  {
    "objectID": "valorize_content2.html#configuring-scales-and-axes",
    "href": "valorize_content2.html#configuring-scales-and-axes",
    "title": "3  Content 2",
    "section": "3.2 Configuring Scales and Axes",
    "text": "3.2 Configuring Scales and Axes\n\n3.2.1 Plotting Antibiotic Resistance: Adjusting the Scale Type\nLet’s start by looking at a simple dot plot of the MIC for Neomycin.\n\nalt.Chart(antibiotics).mark_circle().encode(\n    alt.X('Neomycin:Q')\n)\n\n\n\n\n\n\nWe can see that the MIC values span orders of magnitude: most points to cluster on the left, with a few large outliers to the right.\nBy default Altair uses a linear mapping between the domain values (MIC) and the range values (pixels). To get a better overview of the data, we can apply a different scale transformation.\nTo change the scale type, we’ll set the scale attribute, using the alt.Scale method and type parameter.\nHere’s the result of using a square root (sqrt) scale type. Distances in the pixel range now correspond to the square root of distances in the data domain.\n\nalt.Chart(antibiotics).mark_circle().encode(\n    alt.X('Neomycin:Q',\n          scale=alt.Scale(type='sqrt'))\n)\n\n\n\n\n\n\nThe points on the left are now better differentiated, but we still see some heavy skew.\nLet’s try using a logarithmic scale (log) instead:\n\nalt.Chart(antibiotics).mark_circle().encode(\n    alt.X('Neomycin:Q',\n          scale=alt.Scale(type='log'))\n)\n\n\n\n\n\n\nNow the data is much more evenly distributed and we can see the very large differences in concentrations required for different bacteria.\nIn a standard linear scale, a visual (pixel) distance of 10 units might correspond to an addition of 10 units in the data domain. A logarithmic transform maps between multiplication and addition, such that log(u) + log(v) = log(u*v). As a result, in a logarithmic scale, a visual distance of 10 units instead corresponds to multiplication by 10 units in the data domain, assuming a base 10 logarithm. The log scale above defaults to using the logarithm base 10, but we can adjust this by providing a base parameter to the scale.\n\n\n3.2.2 Styling an Axis\nLower dosages indicate higher effectiveness. However, some people may expect values that are “better” to be “up and to the right” within a chart. If we want to cater to this convention, we can reverse the axis to encode “effectiveness” as a reversed MIC scale.\nTo do this, we can set the encoding sort property to 'descending':\n\nalt.Chart(antibiotics).mark_circle().encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log'))\n)\n\n\n\n\n\n\nUnfortunately the axis is starting to get a bit confusing: we’re plotting data on a logarithmic scale, in the reverse direction, and without a clear indication of what our units are!\nLet’s add a more informative axis title: we’ll use the title property of the encoding to provide the desired title text:\n\nalt.Chart(antibiotics).mark_circle().encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log'),\n          title='Neomycin MIC (μg/ml, reverse log scale)')\n)\n\n\n\n\n\n\nMuch better!\nBy default, Altair places the x-axis along the bottom of the chart. To change these defaults, we can add an axis attribute with orient='top':\n\nalt.Chart(antibiotics).mark_circle().encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log'),\n          axis=alt.Axis(orient='top'),\n          title='Neomycin MIC (μg/ml, reverse log scale)')\n)\n\n\n\n\n\n\nSimilarly, the y-axis defaults to a 'left' orientation, but can be set to 'right'.\n\n\n3.2.3 Comparing Antibiotics: Adjusting Grid Lines, Tick Counts, and Sizing\nHow does neomycin compare to other antibiotics, such as streptomycin and penicillin?\nTo start answering this question, we can create scatter plots, adding a y-axis encoding for another antibiotic that mirrors the design of our x-axis for neomycin.\n\nalt.Chart(antibiotics).mark_circle().encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log'),\n          title='Neomycin MIC (μg/ml, reverse log scale)'),\n    alt.Y('Streptomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log'),\n          title='Streptomycin MIC (μg/ml, reverse log scale)')\n)\n\n\n\n\n\n\nWe can see that neomycin and streptomycin appear highly correlated, as the bacterial strains respond similarly to both antibiotics.\nLet’s move on and compare neomycin with penicillin:\n\nalt.Chart(antibiotics).mark_circle().encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log'),\n          title='Neomycin MIC (μg/ml, reverse log scale)'),\n    alt.Y('Penicillin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log'),\n          title='Penicillin MIC (μg/ml, reverse log scale)')\n)\n\n\n\n\n\n\nNow we see a more differentiated response: some bacteria respond well to neomycin but not penicillin, and vice versa!\nWhile this plot is useful, we can make it better. The x and y axes use the same units, but have different extents (the chart width is larger than the height) and different domains (0.001 to 100 for the x-axis, and 0.001 to 1,000 for the y-axis).\nLet’s equalize the axes: we can add explicit width and height settings for the chart, and specify matching domains using the scale domain property.\n\nalt.Chart(antibiotics).mark_circle().encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          title='Neomycin MIC (μg/ml, reverse log scale)'),\n    alt.Y('Penicillin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          title='Penicillin MIC (μg/ml, reverse log scale)')\n).properties(width=250, height=250)\n\n\n\n\n\n\nThe resulting plot is more balanced, and less prone to subtle misinterpretations!\nHowever, the grid lines are now rather dense. If we want to remove grid lines altogether, we can add grid=False to the axis attribute. But what if we instead want to reduce the number of tick marks, for example only including grid lines for each order of magnitude?\nTo change the number of ticks, we can specify a target tickCount property for an Axis object. The tickCount is treated as a suggestion to Altair, to be considered alongside other aspects such as using nice, human-friendly intervals. We may not get exactly the number of tick marks we request, but we should get something close.\n\nalt.Chart(antibiotics).mark_circle().encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Neomycin MIC (μg/ml, reverse log scale)'),\n    alt.Y('Penicillin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Penicillin MIC (μg/ml, reverse log scale)')\n).properties(width=250, height=250)\n\n\n\n\n\n\nBy setting the tickCount to 5, we have the desired effect.\nOur scatter plot points feel a bit small. Let’s change the default size by setting the size property of the circle mark. This size value is the area of the mark in pixels.\n\nalt.Chart(antibiotics).mark_circle(size=80).encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Neomycin MIC (μg/ml, reverse log scale)'),\n    alt.Y('Penicillin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Penicillin MIC (μg/ml, reverse log scale)'), \n).properties(width=250, height=250)\n\n\n\n\n\n\nHere we’ve set the circle mark area to 80 pixels. Further adjust the value as you see fit!",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Content 2</span>"
    ]
  },
  {
    "objectID": "valorize_content2.html#configuring-color-legends",
    "href": "valorize_content2.html#configuring-color-legends",
    "title": "3  Content 2",
    "section": "3.3 Configuring Color Legends",
    "text": "3.3 Configuring Color Legends\n\n3.3.1 Color by Gram Staining\nAbove we saw that neomycin is more effective for some bacteria, while penicillin is more effective for others. But how can we tell which antibiotic to use if we don’t know the specific species of bacteria? Gram staining serves as a diagnostic for discriminating classes of bacteria!\nLet’s encode Gram_Staining on the color channel as a nominal data type:\n\nalt.Chart(antibiotics).mark_circle(size=80).encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Neomycin MIC (μg/ml, reverse log scale)'),\n    alt.Y('Penicillin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Penicillin MIC (μg/ml, reverse log scale)'),\n    alt.Color('Gram_Staining:N')\n).properties(width=250, height=250)\n\n\n\n\n\n\nWe can see that Gram-positive bacteria seem most susceptible to penicillin, whereas neomycin is more effective for Gram-negative bacteria!\nThe color scheme above was automatically chosen to provide perceptually-distinguishable colors for nominal (equal or not equal) comparisons. However, we might wish to customize the colors used. In this case, Gram staining results in distinctive physical colorings: pink for Gram-negative, purple for Gram-positive.\nLet’s use those colors by specifying an explicit scale mapping from the data domain to the color range:\n\nalt.Chart(antibiotics).mark_circle(size=80).encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Neomycin MIC (μg/ml, reverse log scale)'),\n    alt.Y('Penicillin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Penicillin MIC (μg/ml, reverse log scale)'),\n    alt.Color('Gram_Staining:N',\n          scale=alt.Scale(domain=['negative', 'positive'], range=['hotpink', 'purple'])\n    )\n).properties(width=250, height=250)\n\n\n\n\n\n\nBy default legends are placed on the right side of the chart. Similar to axes, we can change the legend orientation using the orient parameter:\n\nalt.Chart(antibiotics).mark_circle(size=80).encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Neomycin MIC (μg/ml, reverse log scale)'),\n    alt.Y('Penicillin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Penicillin MIC (μg/ml, reverse log scale)'),\n    alt.Color('Gram_Staining:N',\n          scale=alt.Scale(domain=['negative', 'positive'], range=['hotpink', 'purple']),\n          legend=alt.Legend(orient='left')\n    )\n).properties(width=250, height=250)\n\n\n\n\n\n\nWe can also remove a legend entirely by specifying legend=None:\n\nalt.Chart(antibiotics).mark_circle(size=80).encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Neomycin MIC (μg/ml, reverse log scale)'),\n    alt.Y('Penicillin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Penicillin MIC (μg/ml, reverse log scale)'),\n    alt.Color('Gram_Staining:N',\n          scale=alt.Scale(domain=['negative', 'positive'], range=['hotpink', 'purple']),\n          legend=None\n    )\n).properties(width=250, height=250)\n\n\n\n\n\n\n\n\n3.3.2 Color by Species\nSo far we’ve considered the effectiveness of antibiotics. Let’s turn around and ask a different question: what might antibiotic response teach us about the different species of bacteria?\nTo start, let’s encode Bacteria (a nominal data field) using the color channel:\n\nalt.Chart(antibiotics).mark_circle(size=80).encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Neomycin MIC (μg/ml, reverse log scale)'),\n    alt.Y('Penicillin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Penicillin MIC (μg/ml, reverse log scale)'),\n    alt.Color('Bacteria:N')\n).properties(width=250, height=250)\n\n\n\n\n\n\nThe result is a bit of a mess! There are enough unique bacteria that Altair starts repeating colors from its default 10-color palette for nominal values.\nTo use custom colors, we can update the color encoding scale property. One option is to provide explicit scale domain and range values to indicate the precise color mappings per value, as we did above for Gram staining. Another option is to use an alternative color scheme. Altair includes a variety of built-in color schemes. For a complete list, see the Vega color scheme documentation.\nLet’s try switching to a built-in 20-color scheme, tableau20, and set that using the scale scheme property.\n\nalt.Chart(antibiotics).mark_circle(size=80).encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Neomycin MIC (μg/ml, reverse log scale)'),\n    alt.Y('Penicillin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Penicillin MIC (μg/ml, reverse log scale)'),\n    alt.Color('Bacteria:N',\n          scale=alt.Scale(scheme='tableau20'))\n).properties(width=250, height=250)\n\n\n\n\n\n\nWe now have a unique color for each bacteria, but the chart is still a mess. Among other issues, the encoding takes no account of bacteria that belong to the same genus. In the chart above, the two different Salmonella strains have very different hues (teal and pink), despite being biological cousins.\nTo try a different scheme, we can also change the data type from nominal to ordinal. The default ordinal scheme uses blue shades, ramping from light to dark:\n\nalt.Chart(antibiotics).mark_circle(size=80).encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Neomycin MIC (μg/ml, reverse log scale)'),\n    alt.Y('Penicillin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Penicillin MIC (μg/ml, reverse log scale)'),\n    alt.Color('Bacteria:O')\n).properties(width=250, height=250)\n\n\n\n\n\n\nSome of those blue shades may be hard to distinguish.\nFor more differentiated colors, we can experiment with alternatives to the default blues color scheme. The viridis scheme ramps through both hue and luminance:\n\nalt.Chart(antibiotics).mark_circle(size=80).encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Neomycin MIC (μg/ml, reverse log scale)'),\n    alt.Y('Penicillin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Penicillin MIC (μg/ml, reverse log scale)'),\n    alt.Color('Bacteria:O',\n          scale=alt.Scale(scheme='viridis'))\n).properties(width=250, height=250)\n\n\n\n\n\n\nBacteria from the same genus now have more similar colors than before, but the chart still remains confusing. There are many colors, they are hard to look up in the legend accurately, and two bacteria may have similar colors but different genus.\n\n\n3.3.3 Color by Genus\nLet’s try to color by genus instead of bacteria. To do so, we will add a calculate transform that splits up the bacteria name on space characters and takes the first word in the resulting array. We can then encode the resulting Genus field using the tableau20 color scheme.\n(Note that the antibiotics dataset includes a pre-calculated Genus field, but we will ignore it here in order to further explore Altair’s data transformations.)\n\nalt.Chart(antibiotics).mark_circle(size=80).transform_calculate(\n    Genus='split(datum.Bacteria, \" \")[0]'\n).encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Neomycin MIC (μg/ml, reverse log scale)'),\n    alt.Y('Penicillin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Penicillin MIC (μg/ml, reverse log scale)'),\n    alt.Color('Genus:N',\n          scale=alt.Scale(scheme='tableau20'))\n).properties(width=250, height=250)\n\n\n\n\n\n\nHmm… While the data are better segregated by genus, this cacapohony of colors doesn’t seem particularly useful.\nIf we look at some of the previous charts carefully, we can see that only a handful of bacteria have a genus shared with another bacteria: Salmonella, Staphylococcus, and Streptococcus. To focus our comparison, we might add colors only for these repeated genus values.\nLet’s add another calculate transform that takes a genus name, keeps it if it is one of the repeated values, and otherwise uses the string \"Other\".\nIn addition, we can add custom color encodings using explicit domain and range arrays for the color encoding scale.\n\nalt.Chart(antibiotics).mark_circle(size=80).transform_calculate(\n  Split='split(datum.Bacteria, \" \")[0]'\n).transform_calculate(\n  Genus='indexof([\"Salmonella\", \"Staphylococcus\", \"Streptococcus\"], datum.Split) &gt;= 0 ? datum.Split : \"Other\"'\n).encode(\n    alt.X('Neomycin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Neomycin MIC (μg/ml, reverse log scale)'),\n    alt.Y('Penicillin:Q',\n          sort='descending',\n          scale=alt.Scale(type='log', domain=[0.001, 1000]),\n          axis=alt.Axis(tickCount=5),\n          title='Penicillin MIC (μg/ml, reverse log scale)'),\n    alt.Color('Genus:N',\n          scale=alt.Scale(\n            domain=['Salmonella', 'Staphylococcus', 'Streptococcus', 'Other'],\n            range=['rgb(76,120,168)', 'rgb(84,162,75)', 'rgb(228,87,86)', 'rgb(121,112,110)']\n          ))\n).properties(width=250, height=250)\n\n\n\n\n\n\nWe now have a much more revealing plot, made possible by customizations to the axes and legend. Take a moment to examine the plot above. Notice any surprising groupings?\nThe upper-left region has a cluster of red Streptococcus bacteria, but with a grey Other bacteria alongside them. Meanwhile, towards the middle-right we see another red Streptococcus placed far away from it’s “cousins”. Might we expect bacteria from the same genus (and thus presumably more genetically similar) to be grouped closer together?\nAs it so happens, the underlying dataset actually contains errors. The dataset reflects the species designations used in the early 1950s. However, the scientific consensus has since been overturned. That gray point in the upper-left? It’s now considered a Streptococcus! That red point towards the middle-right? It’s no longer considered a Streptococcus!\nOf course, on its own, this dataset doesn’t fully justify these reclassifications. Nevertheless, the data contain valuable biological clues that went overlooked for decades! Visualization, when used by an appropriately skilled and inquisitive viewer, can be a powerful tool for discovery.\nThis example also reinforces an important lesson: always be skeptical of your data!\n\n\n3.3.4 Color by Antibiotic Response\nWe might also use the color channel to encode quantitative values. Though keep in mind that typically color is not as effective for conveying quantities as position or size encodings!\nHere is a basic heatmap of penicillin MIC values for each bacteria. We’ll use a rect mark and sort the bacteria by descending MIC values (from most to least resistant):\n\nalt.Chart(antibiotics).mark_rect().encode(\n    alt.Y('Bacteria:N',\n      sort=alt.EncodingSortField(field='Penicillin', op='max', order='descending')\n    ),\n    alt.Color('Penicillin:Q')\n)\n\n\n\n\n\n\nWe can further improve this chart by combining features we’ve seen thus far: a log-transformed scale, a change of axis orientation, a custom color scheme (plasma), tick count adjustment, and custom title text. We’ll also exercise configuration options to adjust the axis title placement and legend title alignment.\n\nalt.Chart(antibiotics).mark_rect().encode(\n    alt.Y('Bacteria:N',\n      sort=alt.EncodingSortField(field='Penicillin', op='max', order='descending'),\n      axis=alt.Axis(\n        orient='right',     # orient axis on right side of chart\n        titleX=7,           # set x-position to 7 pixels right of chart\n        titleY=-2,          # set y-position to 2 pixels above chart\n        titleAlign='left',  # use left-aligned text\n        titleAngle=0        # undo default title rotation\n      )\n    ),\n    alt.Color('Penicillin:Q',\n      scale=alt.Scale(type='log', scheme='plasma', nice=True),\n      legend=alt.Legend(titleOrient='right', tickCount=5),\n      title='Penicillin MIC (μg/ml)'\n    )\n)\n\n\n\n\n\n\nAlternatively, we can remove the axis title altogether, and use the top-level title property to add a title for the entire chart:\n\nalt.Chart(antibiotics, title='Penicillin Resistance of Bacterial Strains').mark_rect().encode(\n    alt.Y('Bacteria:N',\n      sort=alt.EncodingSortField(field='Penicillin', op='max', order='descending'),\n      axis=alt.Axis(orient='right', title=None)\n    ),\n    alt.Color('Penicillin:Q',\n      scale=alt.Scale(type='log', scheme='plasma', nice=True),\n      legend=alt.Legend(titleOrient='right', tickCount=5),\n      title='Penicillin MIC (μg/ml)'\n    )\n).configure_title(\n  anchor='start', # anchor and left-align title\n  offset=5        # set title offset from chart\n)",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Content 2</span>"
    ]
  },
  {
    "objectID": "valorize_content2.html#summary",
    "href": "valorize_content2.html#summary",
    "title": "3  Content 2",
    "section": "3.4 Summary",
    "text": "3.4 Summary\nIntegrating what we’ve learned across the notebooks so far about encodings, data transforms, and customization, you should now be prepared to make a wide variety of statistical graphics. Now you can put Altair into everyday use for exploring and communicating data!\nInterested in learning more about this topic?\n\nStart with the Altair Customizing Visualizations documentation.\nFor a complementary discussion of scale mappings, see “Introducing d3-scale”.\nFor a more in-depth exploration of all the ways axes and legends can be styled by the underlying Vega library (which powers Altair and Vega-Lite), see “A Guide to Guides: Axes & Legends in Vega”.\nFor a fascinating history of the antibiotics dataset, see Wainer & Lysen’s “That’s Funny…” in the American Scientist.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Content 2</span>"
    ]
  },
  {
    "objectID": "valorize_support.html",
    "href": "valorize_support.html",
    "title": "4  Kementrian Pendidikan Tinggi, Sains, dan Teknologi",
    "section": "",
    "text": "In this notebook we show you common debugging techniques that you can use if you run into issues with Altair.\nYou can jump to the following sections:\n\nInstallation and Setup when Altair is not installed correctly\nDisplay Issues when you don’t see a chart\nInvalid Specifications when you get an error\nProperties are Being Ignored when you don’t see any errors or warnings\nAsking for Help when you get stuck\nReporting Issues when you find a bug\n\nLink Kemdiktisaintek Klik Disini.\nPendidikan Tinggi, Sains dan Teknologi, memegang peran kunci dalam mewujudkan Indonesia Emas 2045. Kita perlu membangun sistem pendidikan tinggi yang berkeadilan, relevan, dan berdampak. Transformasi ini harus mampu membuka akses seluas mungkin dengan kualitas yang setara di seluruh Indonesia. Diktisaintek Berdampak adalah gerakan nasional untuk mewujudkan hal itu",
    "crumbs": [
      "Support",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Kementrian Pendidikan Tinggi, Sains, dan Teknologi</span>"
    ]
  }
]